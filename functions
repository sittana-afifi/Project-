
### use generate_graph() to transform adjeceny matrix to graph

from graph_tools import *
def generate_graph():
    n = int(input("Enter the size of the matrix:"))  
    print("Enter the entries in a single line (separated by space): ") 
  
#User input of entries in a single line separated by space 
    entries = list(map(int, input().split())) 
    AM = np.array(entries).reshape(n, n) 
    d = Graph(directed=False)
    d.add_vertex(len(AM))
    for i in range(len(AM)):
        for j in range(i,len(AM)):
            if AM[i][j]==1:
                d.add_edge(i,j)
    return( d)

### get the two graphs from prover as adjecny matrix
g0 = list(map(int,input("Enter the first graph(G0) as a list :").strip().split()))
g1 = list(map(int,input("Enter the second graph(G1) as a list :").strip().split()))
print('G0=')
generate_graph(g0)
print('G1=')
generate_graph(g1)


### apply permutation to the graph by using apply_permute()

def apply_permute(p,g):
    g1=[0]*len(p)
    s=min(g)
    if len(p)==len(g):
        for i in range(len(p)):
            g1[i]=g[((p[i]-s)%len(p))]
        pass
    return g1
        
   
   
   ### composite two permutation using composite_permutition()
   
   def composite_permutition(p1,p2):
    g1=[0]*len(p)
    if len(p)==len(g):
        for i in range(len(p)):
            g1[i]=g[((p[i]-1)%len(p))]
        pass
    return g1
   
   
   ## check if two permutation produce the same graph using are_same()
   
   def are_same(g0,g1):
    s=0
    q=0
    for v in g0.vertices():
        s=s+1
    for u in g1.vertices():
        q=q+1
    a=0
    for e in g0.edges():
        for f in g1.edges():
            if e==f :
                a=a+1
                break
    if a==q and s==q :
        return True
    else :
        return False
        
        
### generate permutation those produce different graphs using s_n() 

def s_n(n):
    from itertools import permutations 
    l = list(permutations(range(1, n+1)))
    l1=[]
    l2=[]
    l3=[]
    for i in range(len(l)):
        if l[i][0]==1:
            l1.append(l[i])
    l2=To_list(l1)
    for i in range(len(l2)):
        for j in range(i+1,len(l2)):
            i1=Graph()
            j1=Graph()
            i1=generate_graph(l2[i])
            j1=generate_graph(l2[j])
            if are_same(i1,j1)==True :
                l3.append(l2[i])
    return l3
